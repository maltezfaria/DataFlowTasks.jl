<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · DataFlowTasks.jl</title><meta name="title" content="Getting started · DataFlowTasks.jl"/><meta property="og:title" content="Getting started · DataFlowTasks.jl"/><meta property="twitter:title" content="Getting started · DataFlowTasks.jl"/><meta name="description" content="Documentation for DataFlowTasks.jl."/><meta property="og:description" content="Documentation for DataFlowTasks.jl."/><meta property="twitter:description" content="Documentation for DataFlowTasks.jl."/><meta property="og:url" content="https://maltezfaria.github.io/DataFlowTasks.jl/"/><meta property="twitter:url" content="https://maltezfaria.github.io/DataFlowTasks.jl/"/><link rel="canonical" href="https://maltezfaria.github.io/DataFlowTasks.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>DataFlowTasks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Basic-usage"><span>Basic usage</span></a></li><li><a class="tocitem" href="#Custom-types"><span>Custom types</span></a></li><li><a class="tocitem" href="#Task-graph"><span>Task graph</span></a></li><li><a class="tocitem" href="#Limitations"><span>Limitations</span></a></li></ul></li><li><a class="tocitem" href="profiling/">Debugging &amp; Profiling</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/cholesky/cholesky/">Tiled Cholesky Factorization</a></li><li><a class="tocitem" href="examples/blur-roberts/blur-roberts/">Blur &amp; Roberts image filters</a></li><li><a class="tocitem" href="examples/lcs/lcs/">Longest Common Subsequence</a></li><li><a class="tocitem" href="examples/sort/sort/">Merge sort</a></li><li><a class="tocitem" href="examples/hardware/">Hardware information</a></li></ul></li><li><a class="tocitem" href="troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maltezfaria/DataFlowTasks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/maltezfaria/DataFlowTasks.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DataFlowTasks"><a class="docs-heading-anchor" href="#DataFlowTasks">DataFlowTasks</a><a id="DataFlowTasks-1"></a><a class="docs-heading-anchor-permalink" href="#DataFlowTasks" title="Permalink"></a></h1><p><em>Tasks which automatically respect data-flow dependencies</em></p><h2 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h2><p>This package defines a <a href="references/#DataFlowTasks.@dspawn-Tuple{Any, Vararg{Any}}"><code>@dspawn</code></a> macro which behaves very much like <code>Threads.@spawn</code>, except that it allows the user to specify explicit <em>data dependencies</em> for the spawned <code>Task</code>. This information is then used to automatically infer <em>task dependencies</em> by constructing and analyzing a directed acyclic graph based on how tasks access the underlying data. The premise is that it is sometimes simpler to specify how <em>tasks depend on data</em> than to specify how <em>tasks depend on each other</em>.</p><p>When creating a <code>Task</code> using <a href="references/#DataFlowTasks.@dspawn-Tuple{Any, Vararg{Any}}"><code>@dspawn</code></a>, the following annotations can be used to declare how the <code>Task</code> accesses the data:</p><ul><li>read-only: <code>@R</code> or <code>@READ</code></li><li>write-only: <code>@W</code> or <code>@WRITE</code></li><li>read-write: <code>@RW</code> or <code>@READWRITE</code></li></ul><p>An <code>@R(A)</code> annotation for example implies that <em>data</em> <code>A</code> will be accessed in read-only mode by the <em>task</em>. Here is a simple example:</p><pre><code class="language-julia hljs">using DataFlowTasks

n = 100_000
A = ones(n)

d1 = @dspawn begin
    @RW A

    # in-place work on A
    for i in eachindex(A)
        A[i] = log(A[i]) # A[i] = 0
    end
end

# reduce A
d2 = @dspawn sum(@R A)
# The above is a shortcut for:
#   d2 = @dspawn begin
#       @R A
#       sum(A)
#   end

c = fetch(d2) # 0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0</code></pre><p>Two (asynchronous) tasks were created, both of which access the array <code>A</code>. Because <code>d1</code> writes to <code>A</code>, and <code>d2</code> reads from it, the outcome <code>C</code> is nondeterministic unless we specify an order of precedence. <code>DataFlowTasks</code> reinforces the <strong>sequential consistency</strong> criterion, which is to say that executing tasks in parallel must preserve, up to rounding errors, the result that would have been obtained if they were executed sequentially, following the order in which they were created. In the example above, this means <code>d2</code> will wait on <code>d1</code> because of an inferred data dependency. The outcome is thus always zero.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you replace <code>DataFlowTasks.@dspawn</code> by <code>Threads.@spawn</code> in the example above (and pick an <code>n</code> large enough) you will see that you no longer get <code>0</code> because <code>d2</code> may access an element of <code>A</code> before it has been replaced by zero!</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In the <code>d2</code> example above, a shortcut syntax was introduced, which allows putting access mode annotations directly around arguments in a function call. This is especially useful when the task body is a one-liner. See <a href="references/#DataFlowTasks.@dspawn-Tuple{Any, Vararg{Any}}"><code>@dspawn</code></a> for an exhaustive list of supported ways to create tasks and specify data dependencies.</p></div></div><p>No parallelism was allowed in the previous example due to a data conflict. To see that when parallelism is possible, <code>DataFlowTasks</code> will exploit it, consider this one last example:</p><pre><code class="language-julia hljs">using DataFlowTasks

function run(A)
    d1 = @dspawn begin
        @W A # write to A
        sleep(1)
        fill!(A,0)
    end

    # a reduction on A
    d2 = @dspawn begin
        @R A # read from A
        sleep(10)
        sum(A)
    end

    # another reduction on A
    d3 = @dspawn sum(@R(A))

    t = @elapsed c = fetch(d3)

    @show t,c
end

A = ones(10)
run(copy(A)) # run once to precompile
run(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.002282519, 0.0)</code></pre><p>We see that the elapsed time to <code>fetch</code> the result from <code>d3</code> is on the order of one second. This is expected since <code>d3</code> needs to wait on <code>d1</code> but can be executed concurrently with <code>d2</code>. The result is, as expected, <code>0</code>.</p><p>All examples this far have been simple enough that the dependencies between the tasks could (and probably should) have been inserted <em>by hand</em>. There are certain problems, however, where the constant reuse of memory (mostly for performance reasons) makes a data-flow approach to parallelism a rather natural way to implicitly describe task dependencies. This is the case, for instance, of tiled (also called blocked) matrix factorization algorithms, where task dependencies can become rather difficult to describe in an explicit manner. The <a href="examples/cholesky/cholesky/#tiledcholesky-section">tiled factorization section</a> showcases some non-trivial problems for which <code>DataFlowTask</code>s may be useful.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The main goal of <code>DataFlowTask</code>s is to expose parallelism: two tasks <code>ti</code> and <code>tj</code> can be executed concurrently if one does not write to memory that the other reads. This data-dependency check is done <em>dynamically</em>, and therefore is not limited to tasks in the same lexical scope. Of course, there is an overhead associated with these checks, so whether performance gains can be obtained depend largely on how parallel the algorithm is, as well as how long each individual task takes (compared to the overhead).</p></div></div><h2 id="Custom-types"><a class="docs-heading-anchor" href="#Custom-types">Custom types</a><a id="Custom-types-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-types" title="Permalink"></a></h2><p>In order to infer dependencies between <code>DataFlowTask</code>s, we must be able to determine whether two objects <code>A</code> and <code>B</code> share a common memory space. That is to say, we must know if <em>mutating</em> <code>A</code> can affect <code>B</code>, or vice-versa. This check is performed by the <a href="references/#DataFlowTasks.memory_overlap-Tuple{Any, Any}"><code>memory_overlap</code></a> function:</p><pre><code class="language-julia hljs">using DataFlowTasks: memory_overlap

A = rand(10,10)
B = view(A,1:10)
C = view(A,11:20)

memory_overlap(A,B), memory_overlap(A,C), memory_overlap(B,C)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(true, true, false)</code></pre><p>The example above works because <code>memory_overlap</code> has been defined for some basic <code>AbstractArray</code>s types inside <code>DataFlowTasks</code>. If a specialized method for <code>memory_overlap</code> is not found, <code>DataFlowTasks</code> errs on the safe side and falls back to a generic implementation that always returns <code>true</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using DataFlowTasks: memory_overlap</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct CirculantMatrix # a custom type
           data::Vector{Float64}
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = rand(10);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = CirculantMatrix(v);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; memory_overlap(M,copy(v))</code><code class="nohighlight hljs ansi" style="display:block;">┌ Warning: using fallback `memory_overlap(::Any,::Any) = true`. Consider implementing
│ `DataFlowTasks.memory_overlap(::Main.var&quot;Main&quot;.CirculantMatrix,::Vector{Float64})`.
└ @ DataFlowTasks ~/runner-dataflow-tasks/_work/DataFlowTasks.jl/DataFlowTasks.jl/src/dataflowtask.jl:144
true</code></pre><p>The warning message printed above hints at what should be done:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import DataFlowTasks: memory_overlap</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; memory_overlap(M::CirculantMatrix,v) = memory_overlap(M.data,v) # overload</code><code class="nohighlight hljs ansi" style="display:block;">memory_overlap (generic function with 9 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; memory_overlap(v,M::CirculantMatrix) = memory_overlap(M,v)</code><code class="nohighlight hljs ansi" style="display:block;">memory_overlap (generic function with 10 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; memory_overlap(M,v), memory_overlap(M,copy(v))</code><code class="nohighlight hljs ansi" style="display:block;">(true, false)</code></pre><p>You can now <code>spawn</code> tasks with your custom type <code>CirculantMatrix</code> as a data dependency, and things should work as expected:</p><pre><code class="language-julia hljs">using DataFlowTasks

v  = ones(5);
M1 = CirculantMatrix(v);
M2 = CirculantMatrix(copy(v));

Base.sum(M::CirculantMatrix) = length(M.data)*sum(M.data)

d1 = @dspawn begin
    @W v
    sleep(0.5)
    fill!(v,0)
end;
d2 = @dspawn sum(@R M1)
d3 = @dspawn sum(@R M2)

fetch(d3) # 25
fetch(d2) # 0</code></pre><h2 id="Task-graph"><a class="docs-heading-anchor" href="#Task-graph">Task graph</a><a id="Task-graph-1"></a><a class="docs-heading-anchor-permalink" href="#Task-graph" title="Permalink"></a></h2><p>Each time a <code>Task</code> is spawned using <code>@dspawn</code>, it is added to an internal <code>TaskGraph</code> (see <a href="references/#DataFlowTasks.get_active_taskgraph-Tuple{}"><code>get_active_taskgraph</code></a>) so that its data-dependencies can be tracked and analyzed. There are two important things to know about <code>TaskGraph</code> objects. First, they are buffered to handle at most <code>sz_max</code> tasks at a time: trying to add a task to the <code>TaskGraph</code> when it is full will block. This is done to keep the cost of analyzing the data dependencies under control. You can modify the buffer size as follows:</p><pre><code class="language-julia hljs">taskgraph = DataFlowTasks.get_active_taskgraph()
resize!(taskgraph,200)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataFlowTasks.TaskGraph with 2 active nodes, 0 finished nodes, and 0 edges (capacity of 200 nodes)</code></pre><p>Second, when the computation of a task in the <code>TaskGraph</code> is completed, it gets pushed into a <code>finished</code> channel, to be eventually processed and <code>pop</code>ed from the graph by the <code>dag_cleaner</code>. If you want to stop nodes from being removed from the DAG, you may stop the <code>dag_cleaner</code> using:</p><pre><code class="language-julia hljs">DataFlowTasks.stop_dag_cleaner(taskgraph)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Task (done) @0x00007f686c7f7080</code></pre><p>Finished nodes will now remain in the DAG:</p><pre><code class="language-julia hljs">A = ones(5)
@dspawn begin
    @RW A
    A .= 2 .* A
end
@dspawn sum(@R A)
taskgraph</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataFlowTasks.TaskGraph with 4 active nodes, 2 finished nodes, and 1 edge (capacity of 200 nodes)</code></pre><p>Note that stopping the <code>dag_cleaner</code> means <code>finished</code> nodes are no longer removed; since the task graph is a buffered structure, this may cause the execution to halt if it is at full capacity. You can then either <code>resize!</code> it, or simply start the worker (which will result in the processing of the <code>finished</code> channel):</p><pre><code class="language-julia hljs">DataFlowTasks.start_dag_cleaner(taskgraph)
taskgraph</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataFlowTasks.TaskGraph with 2 active nodes, 0 finished nodes, and 0 edges (capacity of 200 nodes)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>There are situations where you may want to use a different <code>TaskGraph</code> temporarily to execute a block of code, and restore the default after. This can be done using the <a href="references/#DataFlowTasks.with_taskgraph-Tuple{Any, Any}"><code>with_taskgraph</code></a> method.</p></div></div><h2 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h2><p>Some current limitations are listed below:</p><ul><li>At present, there is no way to specify priorities for a task. We plan to support such a feature in the near future. Check <a href="https://github.com/maltezfaria/DataFlowTasks.jl/issues/75">this issue</a> to track the development.</li><li>The main thread executes tasks, and is responsible for adding/removing nodes from the DAG. This may hinder parallelism if the main thread is given a long task since the processing of the dag will halt until the main thread becomes free again. This could be a problem if the task execution times are <em>very inhomogeneous</em>; a solution, not currently implemented, would be to allow for blocking the main thread from executing tasks.</li><li>Nesting <code>DataFlowTask</code>s, although possible, can be tricky. See <a href="troubleshooting/#nested-tasks">Nested Tasks</a> for a more in-depth discussion.</li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="profiling/">Debugging &amp; Profiling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 10 June 2024 09:21">Monday 10 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
