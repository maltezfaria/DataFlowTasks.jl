<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Debugging &amp; Profiling · DataFlowTasks.jl</title><meta name="title" content="Debugging &amp; Profiling · DataFlowTasks.jl"/><meta property="og:title" content="Debugging &amp; Profiling · DataFlowTasks.jl"/><meta property="twitter:title" content="Debugging &amp; Profiling · DataFlowTasks.jl"/><meta name="description" content="Documentation for DataFlowTasks.jl."/><meta property="og:description" content="Documentation for DataFlowTasks.jl."/><meta property="twitter:description" content="Documentation for DataFlowTasks.jl."/><meta property="og:url" content="https://maltezfaria.github.io/DataFlowTasks.jl/profiling/"/><meta property="twitter:url" content="https://maltezfaria.github.io/DataFlowTasks.jl/profiling/"/><link rel="canonical" href="https://maltezfaria.github.io/DataFlowTasks.jl/profiling/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataFlowTasks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Getting started</a></li><li class="is-active"><a class="tocitem" href>Debugging &amp; Profiling</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-[LogInfo](@ref-DataFlowTasks.LogInfo)"><span>Creating a <code>LogInfo</code></span></a></li><li><a class="tocitem" href="#DAG-visualization"><span>DAG visualization</span></a></li><li><a class="tocitem" href="#Scheduling-and-profiling-information"><span>Scheduling and profiling information</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/cholesky/cholesky/">Tiled Cholesky Factorization</a></li><li><a class="tocitem" href="../examples/blur-roberts/blur-roberts/">Blur &amp; Roberts image filters</a></li><li><a class="tocitem" href="../examples/lcs/lcs/">Longest Common Subsequence</a></li><li><a class="tocitem" href="../examples/sort/sort/">Merge sort</a></li><li><a class="tocitem" href="../examples/hardware/">Hardware information</a></li></ul></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Debugging &amp; Profiling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Debugging &amp; Profiling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maltezfaria/DataFlowTasks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/maltezfaria/DataFlowTasks.jl/blob/main/docs/src/profiling.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="visualization-section"><a class="docs-heading-anchor" href="#visualization-section">Debugging &amp; Profiling</a><a id="visualization-section-1"></a><a class="docs-heading-anchor-permalink" href="#visualization-section" title="Permalink"></a></h1><p><code>DataFlowTasks</code> defines two visualization tools that help when debugging and profiling parallel programs:</p><ul><li>a visualization of the Directed Acyclic Graph (DAG) internally representing task dependencies;</li><li>a visualization of how tasks were scheduled during a run, alongside with other information helping understand what limits the performances of the computation.</li></ul><div class="admonition is-info"><header class="admonition-header">Weak dependencies</header><div class="admonition-body"><p>Visualization tools require additional dependencies (such as <code>Makie</code> or <code>GraphViz</code>) which are only needed during the development stage. We are therefore only declaring those as <em>weak dependencies</em> (for Julia v1.9 and above). The user can either set up a stacked environment in which these dependencies are available, or use the <a href="../references/#DataFlowTasks.stack_weakdeps_env!-Tuple{}"><code>DataFlowTasks.stack_weakdeps_env!()</code></a> function which handles the environment stack automatically.</p></div></div><p>Let&#39;s first introduce a small example that will help illustrate the features introduced here:</p><pre><code class="language-julia hljs">using DataFlowTasks

# Utility functions
init!(x)    = (x .= rand())     # Write
mutate!(x)  = (x .= exp.(x))    # Read+Write
result(x,y) = sum(x) + sum(y)   # Read

# Main work function
function work(A, B)
    # Initialization
    @dspawn init!(@W(A))               label=&quot;init A&quot;
    @dspawn init!(@W(B))               label=&quot;init B&quot;

    # Mutation
    @dspawn mutate!(@RW(A))            label=&quot;mutate A&quot;
    @dspawn mutate!(@RW(B))            label=&quot;mutate B&quot;

    # Final read
    res = @dspawn result(@R(A), @R(B)) label=&quot;read A,B&quot;
    fetch(res)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">work (generic function with 1 method)</code></pre><h2 id="Creating-a-[LogInfo](@ref-DataFlowTasks.LogInfo)"><a class="docs-heading-anchor" href="#Creating-a-[LogInfo](@ref-DataFlowTasks.LogInfo)">Creating a <a href="../references/#DataFlowTasks.LogInfo"><code>LogInfo</code></a></a><a id="Creating-a-[LogInfo](@ref-DataFlowTasks.LogInfo)-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-[LogInfo](@ref-DataFlowTasks.LogInfo)" title="Permalink"></a></h2><p>In order to inspect code which makes use of <code>DataFlowTask</code>s, you can use the <a href="../references/#DataFlowTasks.@log-Tuple{Any}"><code>DataFlowTasks.@log</code></a> macro to keep a trace of the various parallel events and the underlying <code>DAG</code>. Note that to avoid profiling the compilation time, it is often advisable to perform a &quot;dry run&quot; of the code first, as done in the example below:</p><pre><code class="language-julia hljs"># Context
A = ones(2000, 2000)
B = ones(3000, 3000)

# precompilation run
work(copy(A),copy(B))

# activate logging of events
log_info = DataFlowTasks.@log work(A, B)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LogInfo with 5 logged tasks
</code></pre><p>The <code>log_info</code> object above, of <a href="../references/#DataFlowTasks.LogInfo"><code>LogInfo</code></a> type, contains information that can be used to reconstruct both the inferred task dependencies, and the parallel execution traces of the <code>DataFlowTask</code>s. A summary of this information can be displayed using <a href="../references/#DataFlowTasks.describe-Tuple{DataFlowTasks.LogInfo}"><code>DataFlowTasks.describe</code></a>, as illustrated next:</p><pre><code class="language-julia hljs">DataFlowTasks.describe(log_info; categories=[&quot;init&quot;, &quot;mutate&quot;, &quot;read&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">• Elapsed time           : 0.092
  ├─ Critical Path       : 0.092
  ╰─ No-Wait             : 0.017

• Run time               : 0.737
  ├─ Computing           :   0.138
  │  ├─ init             :     0.022
  │  ├─ mutate           :     0.103
  │  ├─ read             :     0.014
  │  ╰─ unlabeled        :     0.000
  ├─ Task Insertion      :   0.000
  ╰─ Other (idle)        :   0.598</code></pre><p>More powerful visualization capabilities, such as displaying the underlying <code>DAG</code> or showing the parallel trace of the tasks executed, are available upon loading additional packages such as <code>GraphViz</code> or <code>Makie</code>. These are discussed in the following sections, where we also explain in more detail the meaning of the numbers output by <a href="../references/#DataFlowTasks.describe-Tuple{DataFlowTasks.LogInfo}"><code>DataFlowTasks.describe</code></a>.</p><div class="admonition is-success"><header class="admonition-header">Fetching results in `@log` blocks</header><div class="admonition-body"><p>When using <code>@log</code>, you typically want the block of code being benchmarked to wait for the completion of its <code>DataFlowTask</code>s before returning (otherwise the <code>LogInfo</code> object that is returned may lack information regarding the <code>DataFlowTask</code>s that have not been completed). In the example above, that was achieved through the use of <code>fetch</code> in the last line of the <code>work</code> function.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Profiling functions that `yield`</header><div class="admonition-body"><p>The logged execution time of each <code>DataFlowTask</code> is the time elapsed between the moment the code block passed to <code>@dspawn</code> starts executing, and the moment it finishes. This means that if the code block <code>yield</code>s, the time recorded may not be representative of the actual time the task spent <em>running</em>.</p></div></div><h2 id="DAG-visualization"><a class="docs-heading-anchor" href="#DAG-visualization">DAG visualization</a><a id="DAG-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#DAG-visualization" title="Permalink"></a></h2><p>In order to better understand what this example does, and check that <em>data dependencies</em> were suitably annotated, it can be useful to look at the Directed Acyclic Graph (DAG) representing <em>task dependencies</em> as they were inferred by <code>DataFlowTasks</code>. The DAG can be visualized by creating a <a href="../references/#GraphViz.Graph-Tuple{DataFlowTasks.LogInfo}"><code>GraphViz.Graph</code></a> out of it:</p><pre><code class="language-julia hljs">using GraphViz
GraphViz.Graph(log_info)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.50.0 (20211204.2007)
 -->
<!-- Title: dag Pages: 1 -->
<svg width="240pt" height="188pt"
 viewBox="0.00 0.00 240.24 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
<title>dag</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-184 236.24,-184 236.24,4 -4,4"/>
<!-- 46194 -->
<g id="node1" class="node">
<title>46194</title>
<ellipse fill="none" stroke="black" stroke-width="2" cx="53.3" cy="-162" rx="36" ry="18"/>
<text text-anchor="middle" x="53.3" y="-158.3" font-family="Times,serif" font-size="14.00">init A</text>
</g>
<!-- 46196 -->
<g id="node5" class="node">
<title>46196</title>
<ellipse fill="none" stroke="black" stroke-width="2" cx="53.3" cy="-90" rx="53.09" ry="18"/>
<text text-anchor="middle" x="53.3" y="-86.3" font-family="Times,serif" font-size="14.00">mutate A</text>
</g>
<!-- 46194&%2345;&gt;46196 -->
<g id="edge4" class="edge">
<title>46194&%2345;&gt;46196</title>
<path fill="none" stroke="black" stroke-width="2" d="M53.3,-143.7C53.3,-135.98 53.3,-126.71 53.3,-118.11"/>
<polygon fill="black" stroke="black" stroke-width="2" points="56.8,-118.1 53.3,-108.1 49.8,-118.1 56.8,-118.1"/>
</g>
<!-- 46197 -->
<g id="node2" class="node">
<title>46197</title>
<ellipse fill="none" stroke="red" stroke-width="2" cx="178.3" cy="-90" rx="53.89" ry="18"/>
<text text-anchor="middle" x="178.3" y="-86.3" font-family="Times,serif" font-size="14.00">mutate B</text>
</g>
<!-- 46198 -->
<g id="node4" class="node">
<title>46198</title>
<ellipse fill="none" stroke="red" stroke-width="2" cx="115.3" cy="-18" rx="50.89" ry="18"/>
<text text-anchor="middle" x="115.3" y="-14.3" font-family="Times,serif" font-size="14.00">read A,B</text>
</g>
<!-- 46197&%2345;&gt;46198 -->
<g id="edge3" class="edge">
<title>46197&%2345;&gt;46198</title>
<path fill="none" stroke="red" stroke-width="2" d="M163.37,-72.41C155.44,-63.61 145.56,-52.63 136.82,-42.92"/>
<polygon fill="red" stroke="red" stroke-width="2" points="139.41,-40.56 130.12,-35.47 134.21,-45.24 139.41,-40.56"/>
</g>
<!-- 46195 -->
<g id="node3" class="node">
<title>46195</title>
<ellipse fill="none" stroke="red" stroke-width="2" cx="178.3" cy="-162" rx="36.29" ry="18"/>
<text text-anchor="middle" x="178.3" y="-158.3" font-family="Times,serif" font-size="14.00">init B</text>
</g>
<!-- 46195&%2345;&gt;46197 -->
<g id="edge1" class="edge">
<title>46195&%2345;&gt;46197</title>
<path fill="none" stroke="red" stroke-width="2" d="M178.3,-143.7C178.3,-135.98 178.3,-126.71 178.3,-118.11"/>
<polygon fill="red" stroke="red" stroke-width="2" points="181.8,-118.1 178.3,-108.1 174.8,-118.1 181.8,-118.1"/>
</g>
<!-- 46196&%2345;&gt;46198 -->
<g id="edge2" class="edge">
<title>46196&%2345;&gt;46198</title>
<path fill="none" stroke="black" stroke-width="2" d="M67.99,-72.41C75.71,-63.69 85.32,-52.85 93.85,-43.21"/>
<polygon fill="black" stroke="black" stroke-width="2" points="96.7,-45.28 100.71,-35.47 91.46,-40.64 96.7,-45.28"/>
</g>
</g>
</svg>
'/><p>When the working environment supports rich media, the DAG will be displayed automatically. In other cases, it is possible to export it to an image using <a href="../references/#DataFlowTasks.savedag"><code>DataFlowTasks.savedag</code></a>:</p><pre><code class="language-julia hljs">dag = GraphViz.Graph(log_info)
DataFlowTasks.savedag(&quot;profiling-example.svg&quot;, dag)</code></pre><p>Note how the task labels (which were provided as extra arguments to <code>@dspawn</code>) are used in the DAG rendering and make it more readable. In the DAG visualization, the <em>critical path</em> is highlighted in red: it is the sequential path that took the longest run time during the computation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The run time of this critical path imposes a hard bound on parallel performances: no matter how many threads are available, it is not possible for the computation to take less time than the duration of the critical path.</p></div></div><h2 id="Scheduling-and-profiling-information"><a class="docs-heading-anchor" href="#Scheduling-and-profiling-information">Scheduling and profiling information</a><a id="Scheduling-and-profiling-information-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduling-and-profiling-information" title="Permalink"></a></h2><p>The collected scheduling &amp; profiling information can be visualized using <a href="../references/#MakieCore.plot-Tuple{DataFlowTasks.LogInfo}"><code>Makie.plot</code></a> on the <code>log_info</code> object (note that using the <code>GLMakie</code> backend brings a bit more interactivity than <code>CairoMakie</code>):</p><pre><code class="language-julia hljs">using CairoMakie # or GLMakie to benefit from more interactivity
plot(log_info; categories=[&quot;init&quot;, &quot;mutate&quot;, &quot;read&quot;])</code></pre><img src="83736d45.png" alt="Example block output"/><p>The <code>categories</code> keyword argument allows grouping tasks in categories according to their labels. In the example above, all tasks containing <code>&quot;mutate&quot;</code> in their label will be grouped in the same category.</p><p>Note : be careful with giving similar labels. If tasks have &quot;R&quot; and &quot;RW&quot; labels, and the substrings given to the plot&#39;s argument are also &quot;R&quot;, and &quot;RW&quot;, then all tasks will be in the category &quot;R&quot; (because &quot;R&quot; can be found in &quot;RW&quot;). Regular expressions can be given instead of substrings in order to avoid such issues.</p><p>Let us explore the various parts of this graph.</p><h3 id="Parallel-Trace"><a class="docs-heading-anchor" href="#Parallel-Trace">Parallel Trace</a><a id="Parallel-Trace-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Trace" title="Permalink"></a></h3><p>The main plot (at the top) is the parallel trace visualization. In this example there were two threads; we can see on which thread the task was run, and the time it took.</p><p>Even though tasks are grouped in categories by considering substrings in their labels, the full label is shown when hovering over a task in the interactive visualization (i.e. when using <code>GLMakie</code> instead of <code>CairoMakie</code>).</p><p>The plot also shows the time spent inserting nodes in the graph (which is part of the overhead incurred by the use of <code>DataFlowTasks</code>): these insertion times are visualized as red tasks. They are not visible for such a small example, but the interactive visualization allows zooming on the plot to search for those small tasks.</p><p>Also note that inserting tasks into the graph involves memory allocations, and may thus trigger garbage collector sweeps. When this happens, the time spent in the garbage collector is also shown in the plot.</p><h3 id="Run-time:-breakdown-by-activity"><a class="docs-heading-anchor" href="#Run-time:-breakdown-by-activity">Run time: breakdown by activity</a><a id="Run-time:-breakdown-by-activity-1"></a><a class="docs-heading-anchor-permalink" href="#Run-time:-breakdown-by-activity" title="Permalink"></a></h3><p>A barplot in the bottom left corner of the window gives us information on the break-down of parallel run times (summed over all threads):</p><ul><li><code>Computing</code> represents the total time spent in the tasks bodies (i.e. &quot;useful&quot; work);</li><li><code>Task Insertion</code> represents the total time spent inserting nodes in the DAG (i.e. overhead induced by <code>DataFlowTasks</code>), possibly including any time spent in the GC if it is triggered by a memory allocation in the task insertion process;</li><li><code>Other (idle)</code> represents the total idle time on all threads (which may be due to bad scheduling, or simply arise by lack of enough exposed parallelism in the algorithm).</li></ul><h3 id="Elapsed-time-and-bounds"><a class="docs-heading-anchor" href="#Elapsed-time-and-bounds">Elapsed time &amp; bounds</a><a id="Elapsed-time-and-bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Elapsed-time-and-bounds" title="Permalink"></a></h3><p>A barplot in the bottom center of the window tries to present insightful information about the elapsed (wall-clock) time of the computation, and its limiting factors:</p><ul><li><p><code>Elapsed</code> represents the measured &quot;wall clock time&quot; of the computation; it should be larger than both of the bounds described below;</p></li><li><p><code>Critical Path</code> represents the time spent in the longest sequential path in the DAG (shown in red in the DAG visualization). As said above, it bounds the performance in that even infinitely many threads would still have to compute this path sequentially;</p></li><li><p><code>No-Wait</code> represents the duration of a hypothetical computation in which all computing time would be evenly distributed among threads (i.e. no thread would ever have to wait). This also bounds the total time because it does not account for dependencies between tasks.</p></li></ul><p>When looking for faster response times, this graph may suggest sensible ways to explore. If the measured time is close to the critical path duration, then adding more threads will be of no help, but decomposing the work in smaller tasks may be useful. On the other hand, if the measured time is close to the &quot;without waiting&quot; bound, then adding more workers may reduce the wall clock time and scale relatively well.</p><h3 id="Computing-time:-breakdown-by-category"><a class="docs-heading-anchor" href="#Computing-time:-breakdown-by-category">Computing time: breakdown by category</a><a id="Computing-time:-breakdown-by-category-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-time:-breakdown-by-category" title="Permalink"></a></h3><p>A barplot in the bottom right of the window displays a break-down of the total computing time (<em>i.e.</em> the total time spent on all threads while performing user-defined tasks), grouped by user-provided category as explained above.</p><p>When trying to optimize the sequential performance of the algorithm, this is where one can get data about what actually takes time (and therefore could produce large gains in performance if it could be optimized).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Getting started</a><a class="docs-footer-nextpage" href="../examples/cholesky/cholesky/">Tiled Cholesky Factorization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Saturday 8 June 2024 16:57">Saturday 8 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
