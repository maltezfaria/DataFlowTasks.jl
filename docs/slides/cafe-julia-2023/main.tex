\documentclass{beamer}

\beamertemplatenavigationsymbolsempty

\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{minted}
\usepackage{tikz}

\usetikzlibrary{graphs,quotes,arrows.meta}
\definecolor{themegreen}{RGB}{0,100,0}
\definecolor{themelightgreen}{RGB}{230,239,230}
\definecolor{themelightblue}{RGB}{215,215,240}

% set graphics path to figure
\graphicspath{{./figures/}}

\usetheme{Madrid}
\usecolortheme{seahorse}
%Information to be included in the title page:
\title[DataFlowTasks] % optional short title
{DataFlowTasks.jl}

% Custom commands
\newcommand{\DFT}{\texttt{DataFlowTasks.jl}}

\subtitle{Julia \texttt{Task}s which automatically handle data-dependencies}

\author[Faria, Févotte] % short version of authors
{Luiz~M.~Faria\inst{1} \and François Févotte\inst{2}}

\institute[]
{
    \inst{1}%
    Chargé de recherche INRIA\\
    POEMS Laboratory
    \and
    \inst{2}%
    Chief Scientist\\
    TriScale innov
}

\date{\today}

\titlegraphic{
  \includegraphics[height=0.5cm]{inr_logo_rouge.png}\hspace{2em}
  \includegraphics[height=0.5cm]{poems_logo.png}\hspace{2em}
  \includegraphics[height=0.5cm]{triscale_couleur_texteadroite.png}
}

\begin{document}

\frame{\titlepage}

% small textsize on frame
\begin{frame}[fragile]
\frametitle{Overview}

\begin{itemize}
    \item \DFT{} is a Julia package dedicated to parallel programming on multi-core shared memory CPUs.
    \item Automatically infer \texttt{Task} interdependencies based on user annotations (\mintinline{julia}{@R, @W, @RW}).
    \item Heavily inspired by task programming libraries such as StarPU.
    \item Simple API: \mintinline{julia}{@dspawn} macro.
\end{itemize}
%
\begin{columns}[t]
\column{0.3\textwidth}
\begin{exampleblock}{}
\begin{minted}[fontsize=\footnotesize]{julia}
function foo!(A)
  fill!(A, 0)          
  view(A, 1:2) .+= 2   
  view(A, 3:4) .+= 3   
  sum(A)               
end
\end{minted}
\end{exampleblock}
\center \begin{tikzpicture}[scale=0.75, every node/.style={transform shape}]
\graph[nodes={draw,circle}] {
1 -> 2 -> 3 -> 4
};
\end{tikzpicture}
 
\column{0.6\textwidth}

\begin{exampleblock}{}
\begin{minted}[fontsize=\footnotesize]{julia}
function foo!(A)
  @dspawn fill!(@W(A), 0)         # task 1
  @dspawn @RW(view(A, 1:2)) .+= 2 # task 2
  @dspawn @RW(view(A, 3:4)) .+= 3 # task 3
  @dspawn sum(@R(A))              # task 4
end
\end{minted}
\end{exampleblock}
\center \begin{tikzpicture}[scale=0.75, every node/.style={transform shape}]
\graph[nodes={draw,circle}] {
  1 -> {2, 3} -> 4
};
\end{tikzpicture}

\end{columns}

% In this presentation, we will explore the features and benefits of \DFT{} in the context of efficient parallel programming.

\end{frame}

\begin{frame}
    \frametitle{Table of Contents}
    \tableofcontents
\end{frame}

\section{Introduction}

\subsection{Task based parallelism in Julia}

\begin{frame}[fragile]
\frametitle{Task based parallelism}
\begin{itemize}
    \item A task is a unit of execution or a unit of work
    \item \mintinline{julia}{Task} objects can be created using \mintinline{julia}{@task}
    \item Once created, \mintinline{julia}{Task} objects must be scheduled for execution
    \item Usually, \mintinline{julia}{Task}s are created + scheduled using \mintinline
    {julia}{@spawn}
    \item \alert{Responsibility of synchronizing tasks is left to the programmer}
\end{itemize}

\begin{columns}
\column{0.7\textwidth}    

\begin{example}[Synchronizing tasks]
\begin{minted}{julia}    
A = rand(4)
t1 = @spawn fill!(A,0)
t2 = @spawn (wait(t1); view(A,1:2) += 2)
t3 = @spawn (wait(t1); view(A,3:4) += 3)
t4 = @spawn (wait(t2); wait(t3); sum(A))
fetch(t4)
\end{minted}
\end{example}

\column{0.2\textwidth}

\begin{tikzpicture}
    % Nodes
    \node[circle, draw] (1) at (0, 0) {1};
    \node[circle, draw] (2) at (-0.5, -1) {2};
    \node[circle, draw] (3) at (0.5, -1) {3};
    \node[circle, draw] (4) at (0, -2) {4};
    % Edges
    \draw[->, thick] (1) -- (2);
    \draw[->, thick] (1) -- (3);
    \draw[->, thick] (2) -- (4);
    \draw[->, thick] (3) -- (4);
\end{tikzpicture}

\end{columns}

\end{frame}

\subsection{Motivation}

\begin{frame}[fragile]
\frametitle{Motivation}

\begin{itemize}
    \item Many algorithms make constant re-use of data for efficiency. 
    % \begin{itemize}
    %     \item Merge sort
    %     \item In-place matrix factorization
    %     \item ...
    % \end{itemize}
    \item Reasoning about \mintinline{julia}{Task} interdependencies can be challenging.
    \item Sometimes, simpler to reason about how \mintinline{julia}{Task}s depends on data than how \mintinline{julia}{Task}s depend on each other
\end{itemize}

\begin{example}[Synchronizing tasks]
\begin{minted}[fontsize=\small]{julia}    
A = rand(4)
t1 = @spawn fill!(A,0)                   # RW access to A
t2 = @spawn (wait(t1); view(A,1:2) += 2) # RW access to A[1:2]   
t3 = @spawn (wait(t1); view(A,3:4) += 3) # RW access to A[3:4]
t4 = @spawn (wait(t2); wait(t3); sum(A)) # R access to A
fetch(t4)
\end{minted}
\end{example}

\end{frame}

\subsection{Basic idea}

\begin{frame}[fragile]

\frametitle{Basic idea}
\begin{enumerate}
    \item \textcolor<4->{lightgray}{Extract data dependency from user annotations}
    \item \textcolor<1-3,10->{lightgray}{Infer task dependency from data dependency}
    \item \textcolor<1-9>{lightgray}{Schedule tasks with inferred dependencies}
\end{enumerate}

\center
\begin{tikzpicture}[scale=0.9, every node/.style={transform shape}]
  % Tasks
  \node<2->[circle, draw] (1) at (0,  0) {1};
  \node<2>[circle, draw, fill=themegreen, text=white] at (0,  0) {1};
  \node<4,6,9>[circle, draw, fill=themelightblue] at (0,  0) {1};
  
  \node<3->[circle, draw] (2) at (2,  1) {2};
  \node<3-4>[circle, draw, fill=themegreen, text=white] at (2,  1) {2};
  \node<5,8>[circle, draw, fill=themelightblue] at (2,  1) {2};
  
  \node<5->[circle, draw] (3) at (2, -1) {3};
  \node<5-6>[circle, draw, fill=themegreen, text=white] at (2, -1) {3};
  \node<7>[circle, draw, fill=themelightblue] at (2, -1) {3};

  \node<7->[circle, draw, fill=themegreen, text=white] (4) at (4,  0) {4};
  
  % Data
  \node<1->[rectangle, draw, fill=themelightgreen, anchor=west] (A)  at (-3.5,  0)   {A};
  \node<3->[rectangle, draw, fill=themelightgreen, anchor=west] (A1) at (-3.5,  1) {\texttt{view(A,1:2)}};
  \node<5->[rectangle, draw, fill=themelightgreen, anchor=west] (A2) at (-3.5, -1) {\texttt{view(A,3:4)}};
  
  % Task -> Data dependencies
  \draw<2->[->, dashed] (1) -- node[midway, below]{\scriptsize\ttfamily W} (A);
  \draw<3->[->, dashed] (2) -- node[midway, above]{\scriptsize\ttfamily RW} (A1) ;
  \draw<5->[->, dashed] (3) -- node[midway, above]{\scriptsize\ttfamily RW} (A2);
  \draw<7-> (4) edge[out=170, in=5, dashed, ->] node[pos=0.87, above]{\scriptsize\ttfamily R} (A.north east);
  
  % Task -> Task dependencies
  \draw<4->[->, thick] (1) -- (2);
  \draw<6->[->, thick] (1) -- (3);
  \draw<8->[->, thick] (2) -- (4);
  \draw<7->[->, thick] (3) -- (4);
  
  % Data <-> Data dependencies
  \draw<4,8>[<->, thick, red] (A.west)  -- ++(-0.5,0) |- (A1.west);
  \draw<6,7>[<->, thick, red] (A.west)  -- ++(-0.5,0) |- (A2.west);
  \draw<5>[<->, thick, themegreen] (A1.west) -- ++(-0.5,0) |- (A2.west);
  \draw<9>[<->, thick, red] (A.south west) -- ++(-0.5,0) |- (A.north west);

  % Bounding box
  \node at (-4,-1.3) {};
  \node at (4.5,1.3) {};
\end{tikzpicture}

\begin{columns}[T]
  \column{0.42\textwidth}
\begin{exampleblock}{User-written code}
\begin{minted}[fontsize=\footnotesize,escapeinside=||,beameroverlays=true]{julia}
|\onslide<1->|A = rand(4)
|\onslide<2->|@dspawn fill!(@W(A),0)
|\onslide<3->|@dspawn @RW(view(A,1:2)) += 2
|\onslide<5->|@dspawn @RW(view(A,3:4)) += 3
|\onslide<7->|@dspawn sum(@R(A))

|\onslide<1->|
\end{minted}    
\end{exampleblock}
  
  \column{0.50\textwidth}
\begin{onlyenv}<4-9>
  \begin{exampleblock}{Behind the scenes: DAG}
\begin{minted}[fontsize=\footnotesize,escapeinside=||]{julia}
# Note the quadratic complexity!
for i in 1:N, j in i:-1:1
  # Detect conflict between i and j
  for di in data(i), dj in data(j)
    if memory_overlap(di, dj)
      add_edge(j, i)
\end{minted}
\end{exampleblock}
\end{onlyenv}
\begin{onlyenv}<10>
\begin{exampleblock}{Behind the scenes: task scheduling}
\begin{minted}[fontsize=\footnotesize]{julia}
t4 = Threads.@spawn begin
  wait(t2); wait(t3)
  sum(A)
end
\end{minted}
\end{exampleblock}
\end{onlyenv}
\end{columns}

% \alert{Note the quadratic complexity in the number of tasks!}

\end{frame}


\section{\mintinline{julia}{Implementation details}}

\subsection{\mintinline{julia}{DataFlowTask}}

\begin{frame}[fragile]

\frametitle{\texttt{DataFlowTask}: \mintinline{julia}{@dspawn} macro}

The \mintinline{julia}{@dspawn} macro does the following:

\begin{itemize}
    \item Scan the \mintinline{julia}{Expr} for \mintinline{julia}{@R, @W, @RW} annotations
    \item Create a \mintinline{julia}{data} and \mintinline{julia}{access_mode}
    tuple
    \item Remove annotations from the \mintinline{julia}{Expr}
    \item Parse keyword arguments    
    \item Create an anonymous function wrapping the new \mintinline{julia}{Expr}
    \item Insert a call to \mintinline{julia}{DataFlowTask} constructor
\end{itemize}

\begin{columns}[T]

\column{0.45\textwidth}    
\begin{exampleblock}{User-written code}    
\begin{minted}{julia}
@dspawn(foo!(@W(B), @R(A)),
        label="foo!")
\end{minted}
\end{exampleblock}


\column{0.4\textwidth}    

\begin{exampleblock}{Macro expansion (approx.)}    
\begin{minted}{julia}
_t = DataFlowTask(
       () -> foo!(B, A),
       (B, A),
       (WRITE, READ);
       label="foo!")
spawn(_t)
\end{minted}
\end{exampleblock}

\end{columns}
%

\end{frame} 

\begin{frame}[fragile]

\frametitle{\texttt{DataFlowTask} structure}

\small{\alert{Inner-constructor of \mintinline{julia}{DataFlowTask} handles much of
the insertion/removal logic:}}

\hrulefill
\begin{minted}[fontsize=\footnotesize]{julia}
mutable struct DataFlowTask
  data::Tuple
  access_mode::NTuple{<:Any,AccessMode}
  task::Task
  ...
  function DataFlowTask(f,data,mode,taskgraph)
    tj = new(data, mode) # incomplete initialization
    addnode!(taskgraph, tj, true) 
    deps = inneighbors(taskgraph, tj) |> copy
    tj.task = @task do
      foreach(ti->wait(ti),deps)
      res = f() # run the underlying function
      put!(taskgraph.finished, tj)
      return res
    end
  end
end
\end{minted}

\end{frame} 

\subsection{\mintinline{julia}{DAG}}

\begin{frame}[fragile]
\frametitle{{\mintinline{julia}{DAG}}}  

A graph data structure to store \mintinline{julia}{DataFlowTask}s and their
dependencies:

\begin{itemize}
  \item Dynamic: nodes are added and removed on the fly
  \item Buffered: limit the number of active nodes
  \item Thread-safe: multiple threads can add/remove nodes
  \item Efficient: easy access to both in- and out-neighbors
\end{itemize}

\hrulefill
\begin{minted}[fontsize=\footnotesize]{julia}
struct DAG{T}
  inoutlist::OrderedDict{T,Tuple{Set{T},Set{T}}}
  cond_push::Condition
  cond_empty::Condition
  lock::ReentrantLock
  sz_max::Base.RefValue{Int}
  counter::Base.RefValue{Int}
  _buffer::Set{Int} # used for transitive reduction
end
\end{minted}
  
\end{frame}

\subsection{\mintinline{julia}{TaskGraph}}

\begin{frame}[fragile]
\frametitle{{\mintinline{julia}{Taskgraph}}}  
  
Essentially a \mintinline{julia}{DAG{DataFlowTask}} with
\begin{itemize}
  \item A channel to store finished tasks  
  \item A dedicated \mintinline{julia}{Task} to remove nodes from the graph
\end{itemize}

\hrulefill
\begin{minted}[fontsize=\footnotesize]{julia}
mutable struct TaskGraph
  dag::DAG{DataFlowTask}
  finished::FinishedChannel{Stoppable{DataFlowTask}}
  dag_cleaner::Task
  function TaskGraph(sz = typemax(Int))
    dag = DAG{DataFlowTask}(sz)
    finished = FinishedChannel{Stoppable{DataFlowTask}}()
    tg = new(dag, finished)
    start_dag_cleaner(tg)
    return tg
  end
end
\end{minted}

\begin{alertblock}{}
\small{Recall that \mintinline{julia}{DataFlowTask} inserts itself in the task
graph, and its underlying \mintinline{julia}{Task} moves it into the finished
channel.}
\end{alertblock}
  
\end{frame}

\subsection{Logging}

\begin{frame}
\frametitle{Logging}

To help with debugging and performance analysis, \DFT{} provides some logging
and visualization tools:
\begin{itemize}
  \item Use the \mintinline{julia}{@log} macro to log the execution of block
  \item Once logged, \mintinline{julia}{describe(loginfo)} shows a summary
  \item If \mintinline{julia}{GraphViz} is installed,
  \mintinline{julia}{Graph(loginfo)} displays the \mintinline{julia}{DAG}
  \item If \mintinline{julia}{Makie} is available,
  \mintinline{julia}{plot(loginfo)} plots the execution trace
\end{itemize}

The basic logic of logging is as follows:
\begin{itemize}
  \item Create a \mintinline{julia}{LogInfo} object is created at the start of the block  
  \item Overwrite the function
  \mintinline{julia}{should_log()} to return \mintinline{julia}{true}
  \item Create tasks. When tasks are created, they check
  \mintinline{julia}{should_log()} and log their execution as well as the
  \mintinline{julia}{DAG} structure
  \item Set \mintinline{julia}{should_log()} to \mintinline{julia}{false}
\end{itemize}

\begin{alertblock}{}
  Note: because \mintinline{julia}{should_log()} is a simple pure function,
  logging should have zero overhead when disabled.
\end{alertblock}

\end{frame}

\begin{frame}[fragile]
\frametitle{Logging}

\begin{minted}[fontsize=\footnotesize]{julia}
function work(A, B)
    @dspawn init!(@W(A))               label="init A"
    @dspawn init!(@W(B))               label="init B"
    @dspawn mutate!(@RW(A))            label="mutate A"
    @dspawn mutate!(@RW(B))            label="mutate B"
    res = @dspawn result(@R(A), @R(B)) label="read A,B"
    fetch(res)
end
log_info = DataFlowTasks.@log work(A, B)
DataFlowTasks.describe(log_info; categories=["init", "mutate", "read"])

\end{minted}

\center \includegraphics[width=0.3\textwidth]{figures/unicode-output.png}
  
\end{frame}

\begin{frame}[fragile]
\frametitle{Logging}

\begin{minted}[fontsize=\footnotesize]{julia}
function work(A, B)
  @dspawn init!(@W(A))               label="init A"
  @dspawn init!(@W(B))               label="init B"
  @dspawn mutate!(@RW(A))            label="mutate A"
  @dspawn mutate!(@RW(B))            label="mutate B"
  res = @dspawn result(@R(A), @R(B)) label="read A,B"
  fetch(res)
end
using GraphViz
GraphViz.Graph(log_info)
  
\end{minted}
  
\center \includegraphics[width=0.3\textwidth]{figures/dag-output.png}
    
\end{frame}

\begin{frame}[fragile]
\frametitle{Logging}

\begin{minted}[fontsize=\footnotesize]{julia}
function work(A, B)
  @dspawn init!(@W(A))               label="init A"
  @dspawn init!(@W(B))               label="init B"
  @dspawn mutate!(@RW(A))            label="mutate A"
  @dspawn mutate!(@RW(B))            label="mutate B"
  res = @dspawn result(@R(A), @R(B)) label="read A,B"
  fetch(res)
end
using CairoMakie # or GLMakie to benefit from more interactivity
plot(log_info; categories=["init", "mutate", "read"])
    
  \end{minted}
    
  \center \includegraphics[width=0.8\textwidth]{figures/trace-output.png}
      
  \end{frame}

\subsection{Summary}

\begin{frame}
\frametitle{Summary}  

\begin{itemize}
  \item When \DFT{} is loaded a default \mintinline{julia}{TaskGraph}, with an
  internal \mintinline{julia}{DAG}, is instantiated.
  \item Upon creation, each \mintinline{julia}{DataFlowTask} object inserts
  itself in the task graph.
  \item Upon completion, each \mintinline{julia}{DataFlowTask} object inserts
  itself in a finished channel
  \item An asynchronous task is responsible for removing finished jobs from the graph
  \item The \mintinline{julia}{@dspawn} macro provides a very convenient way to
  create \mintinline{julia}{DataFlowTask}s
  \item Logging is enabled using the \mintinline{julia}{@log} macro
\end{itemize} 
\end{frame}

\section{Live examples}

\begin{frame}{Live examples}
  \begin{itemize} 
    \item \href{https://maltezfaria.github.io/DataFlowTasks.jl/dev/examples/cholesky/cholesky/}{Tiled cholesky factorization}
    \item
    \href{https://maltezfaria.github.io/DataFlowTasks.jl/dev/examples/blur-roberts/blur-roberts/}{Blur-Roberts filter}
    \item
    \href{https://maltezfaria.github.io/DataFlowTasks.jl/dev/examples/lcs/lcs/}{Longest
    common subsequence}
    \item
    \href{https://maltezfaria.github.io/DataFlowTasks.jl/dev/examples/sort/sort/}{Merge sort}
  \end{itemize}
\end{frame}

\section{Roadmap}


\end{document}